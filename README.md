Реализована проверка наличия параметров в командной строке; если их нет, значения параметров берутся из конфигурационного файла (`.yaml`). Указание пути к конфигурационному файлу в командной строке при запуске программы:

```
-configPath=PATH
```

где `PATH` — полный путь до конфигурационного файла.

```YAML
logger:
  loglevel:                                 #- уровень логирования
  logFileEnable: true                       #- писать ли логи в файл
  logStdoutEnable: true                     #- писать ли логи в консоль
  logFile: ./out.log                        #- путь до файла с логами
  maxSize: 500                              #- максимальный размер файла с логами
  maxAge: 28                                #- сколько хранится файл
  maxBackups: 7                             #- сколько файлов может храниться
  rewriteLog: true                          #- перезаписывать ли файл для логирования
database:
  port:                                     #- порт подключения к БД
  host:                                     #- адрес БД
  user:                                     #- имя пользователя
  password:                                 #- пароль пользователя
  dbName:                                   #- имя БД
  tableNameGlobal: global_cycles            #- имя таблицы, содержащей информацию о глобальном цикле программы
  tableNameResult: results                  #- имя таблицы, содержащей информацию о каждом объекте, над которым производилась работа
  driver: postgres                          #- драйвер БД
```

Доступные уровни логирования: `DEBUG`, `INFO`, `WARNING`, `ERROR`, `CRITICAL`, `PANIC`, `FATAL`. Если `rewriteLog = true` и файл, указанный в поле `logFile`, существует, файл будет перезаписан, иначе логи продолжат записываться в уже существующий. Если указанный файл не существует, он будет создан. Параметры `logFileEnable` и `logStdoutEnable` определяют, будут ли писаться логи в файл и консоль соответственно (если `true`).

Подключение к базе данных реализовано с использованием библиотеки `github.com/jackc/pgx/v5/pgxpool`, чтение конфигурационного файла — с помощью `github.com/spf13/viper`, логгер — с библиотекой `github.com/sirupsen/logrus`. При потере соединения программа не завершается, вместо этого она пытается переподключаться раз в 3 секунды, и после того, как соединение будет восстановлено, продолжает работу в прежнем режиме.

Для тестирования используются пакеты `godoc.org/testing`, `net/http/httptest` и `github.com/golang/mock/gomock`.

Также реализовано корректное завершение работы при получении прерывающего сигнала. Перед завершением программа ожидает 5 секунд для того, чтобы все запущенные процессы успели прерваться.

Таблица `results` является партицируемой. Партиции создаются автоматически на сутки и имеют название вида `results_YYYY_MM_DD`: перед выполнением INSERT-запроса выполняется проверка, что партиция к таблице `results` с данным `start_datetime` существует, если же нет, то партиция создаётся.

## Алгоритм

1. В таблицу `global_cycles` добавляется информация о начале нового цикла работы программы: добавляется время начала работы в поле `start_datetime`:

``` SQL
INSERT INTO start_datetime (start_datetime) VALUES (now())
```

2. Извлекается `id` начатого цикла:

``` SQL
SELECT id FROM global_cycles ORDER BY "id" DESC LIMIT 1
```

3. Задаётся время старта для обработки объектов.

4. Генерируется рандомное число объектов, которые будут добавлены в таблицу `results`; они содержат информацию о времени начала их обработки, id цикла и уникальный uuid (случайное число до 1000).

5. Перед выполнением `INSERT` запроса в таблицу `results` выполняется проверка, существует ли партиция для данного `start_datetime` в таблице `results`: 

``` SQL
SELECT * FROM partition_name
```

где параметр `partition_name` определяется на основе зафиксированного ранее времени начала обработки объектов.

Если нужной партиции нет, она создаётся:

``` SQL
CREATE TABLE partition_name PARTITION OF results
	FOR VALUES FROM ('start_datetime') TO ('end_datetime')
```

где параметры `start_datetime` и `end_datetime` определяются на основе зафиксированного ранее времени.

6. Формируется строка одного `INSERT` запроса в таблицу `results` на основе данных об объектах.

7. В таблицу `results` добавляется информация:

``` SQL
INSERT INTO results (cycles_id, uuid, start_datetime) VALUES vals
```

где `vals` - сформированная в п.6 строка.

8. Выполняется `UPDATE` запрос в таблицу `global_cycles`, в котором обновляется время завершения работы цикла:

``` SQL
UPDATE global_cycles SET end_datetime=now() WHERE id=ID
```

где `ID` - id данного цикла, полученного в п.2.